var webgl, gui, raycaster;
var mouse = new THREE.Vector2(), INTERSECTED;

$(document).ready(init);

function init(){

    webgl = new Webgl(window.innerWidth, window.innerHeight);
    $('.three').append(webgl.renderer.domElement);

    gui = new dat.GUI();
/*
    gui.add(webgl.skyboxObject.scale, 'x').min(-10).max(10);
    gui.add(webgl.skyboxObject.scale, 'y').min(-10).max(10);
    gui.add(webgl.skyboxObject.scale, 'z').min(-10).max(10);
*/
    gui.add(webgl.planeObject.position, 'y').min(-100).max(200);
    gui.add(webgl.planeObject.position, 'z').min(-300).max(100);
    /*
    gui.add(webgl.skyboxObject.position, 'y').min(-100).max(200);
    gui.add(webgl.skyboxObject.position, 'z').min(-100).max(200);
    */
/*
    gui.add(webgl.sharkObject.whiteEye.position, 'x').min(-50).max(50);
    gui.add(webgl.sharkObject.whiteEye.position, 'y').min(-50).max(50);
    gui.add(webgl.sharkObject.whiteEye.position, 'z').min(-50).max(50);
*/
    gui.close();

    raycaster = new THREE.Raycaster();
    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
    //document.addEventListener( 'mousedown', onDocumentMouseDown, false );

    $(window).on('resize', resizeHandler);

    animate();
}

function onDocumentMouseMove(event) {

    event.preventDefault();

    mouse.x =  (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}
/*
function onDocumentMouseDown(event) {

    event.preventDefault();

    mouse.x =  (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}
*/
function resizeHandler() {
    webgl.resize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    webgl.render();
}
var Webgl = (function(){

    function Webgl(width, height){
        // Basic three.js setup
        this.scene = new THREE.Scene();
        
        this.camera = new THREE.PerspectiveCamera(50, width / height, 1, 10000);
        //this.camera = new THREE.OrthographicCamera(width/-2, width/2, height/2, height/-2, 1, 1000);
        this.camera.position.z = 500;

        this.renderer = new THREE.WebGLRenderer();
        this.renderer.setSize(width, height);
        this.renderer.setClearColor(0x000000);

        // Light
        var light = new THREE.PointLight(0xFFFFFF, 1, 2000);
        light.position.set(0, 300, -200);
        this.scene.add(light);

        // Grass
        this.grassObject = new Grass(width, height);
        this.grassObject.position.set(0, 0, 0);
        this.scene.add(this.grassObject);

        // Plane
        this.planeObject = new Plane();
        this.planeObject.position.set(0, 0, 0);
        this.scene.add(this.planeObject);

        // Fishes
        this.boidObject = new Boid(10, 0xAEAEAE);
        this.boidObject.position.set(0, 0, 0);
        this.scene.add(this.boidObject);
        
        this.boid2Object = new Boid(10, 0x520B6B);
        this.boid2Object.position.set(0, 0, 0);
        this.scene.add(this.boid2Object);

        //Particles
        this.particleObject = new Particle();
        this.particleObject.position.set(0, 0, 0);
        this.scene.add(this.particleObject);

        // Plant
    /*
        for (var i = 0 ; i < 4 ; i++) {
            this.plantObject = new Plant();
            this.plantObject.position.set(0, 0, 0);
            this.scene.add(this.plantObject);
        };*/
        

        // Skybox
    /*
        this.skyboxObject = new Skybox();
        this.skyboxObject.position.set(0, 0, 0);
        //this.skyboxObject.scale.set(0, 0, 0);
        this.scene.add(this.skyboxObject);
*/
        // Sound
        this.soundObject = new Sound();

        // Shark
        /*
        this.sharkObject = new Shark();
        this.sharkObject.position.set(1000, 0, -1000);
        this.scene.add(this.sharkObject);*/

    }

    Webgl.prototype.resize = function(width, height) {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    };

    Webgl.prototype.render = function() {
        // MOUSE GESTURE
        var vector = new THREE.Vector3(mouse.x, mouse.y, 0).unproject(this.camera);
        raycaster.set(this.camera.position, vector.sub(this.camera.position).normalize());
        var intersect = raycaster.intersectObject(this.scene.children[3], true);

        if (intersect.length > 0) {

            if (INTERSECTED != intersect[0].object) {
                if (INTERSECTED) 
                    INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

                INTERSECTED = intersect[0].object;
                INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                INTERSECTED.material.emissive.setHex(0xAAAAAA);

                this.boidObject.fleeMouse(vector, intersect[0].object.parent);
/*
                for(var i = 0; i < this.boidObject.children.length; i++) {

                    var boid = this.boidObject.children[i];
                    vector.z = boid.position.z;

                    var distance = boid.position.distanceTo(vector);
                    var minDistance = 50;
                    
                    if(distance < minDistance) {
                        var steer = new THREE.Vector3();

                        steer.subVectors(boid.position, vector);
                        steer.multiplyScalar(0.5 / distance);

                        boid.velocity.x -= steer.x;
                        boid.velocity.y -= steer.y;
                        boid.velocity.z -= steer.z;
                    }
                }*/
            }
        } 
        else {
            if (INTERSECTED) 
                INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

            INTERSECTED = null;
        }
        // END MOUSE GESTURE

        this.renderer.render(this.scene, this.camera);

        this.grassObject.update();
        this.boidObject.update();
        this.boid2Object.update();
        this.particleObject.update();
        //this.sharkObject.update();
    };

    return Webgl;

})();
var Boid = (function(){

    function Boid(nbFishes, color){
        THREE.Object3D.call(this);

        var fishes = [];

        for (var i = 0 ; i < nbFishes ; i++) {

          var fish = new Fish(color);
          fish.position.set((Math.random()*800)-400, (Math.random()*200)-100, (Math.random()*200)-100);
          fish.velocity = new THREE.Vector3(1, 1, 1);
          fishes.push(fish);
          this.add(fish);
        };
    }

    Boid.prototype = new THREE.Object3D;
    Boid.prototype.constructor = Boid;

    Boid.prototype.update = function() {

        for (var i = 0 ; i < this.children.length ; i++) {
            this.moveWith(this.children, this.children[i], 100);
            this.moveCloser(this.children, this.children[i], 100);                    
            this.moveAway(this.children, this.children[i], 40); 
        }

        for (var i = 0 ; i < this.children.length ; i++) {
            this.children[i].update();
            this.move(this.children[i]); 
        }
    }

    Boid.prototype.move = function(currentBoid) {
        
        currentBoid.position.x += currentBoid.velocity.x;
        currentBoid.position.y += currentBoid.velocity.y;
        currentBoid.position.z += currentBoid.velocity.z;

        var width = 400;
        var height = 100;
        var depth = 100;
        var border = 0;
        
        if(currentBoid.position.x <= -width + border || currentBoid.position.x >= width - border) {
            currentBoid.position.x -= currentBoid.velocity.x;                   
            currentBoid.position.x = Math.max(currentBoid.position.x, -width + border);
            currentBoid.position.x = Math.min(currentBoid.position.x,  width - border);
            currentBoid.velocity.x = -currentBoid.velocity.x;
            currentBoid.position.x += currentBoid.velocity.x;
        }
        if(currentBoid.position.y <= -height + border || currentBoid.position.y >= height - border) {
            currentBoid.position.y -= currentBoid.velocity.y;
            currentBoid.position.y = Math.max(currentBoid.position.y, -height + border);
            currentBoid.position.y = Math.min(currentBoid.position.y,  height - border);
            currentBoid.velocity.y = -currentBoid.velocity.y;
            currentBoid.position.y += currentBoid.velocity.y;
        }
        if(currentBoid.position.z <= -depth + border || currentBoid.position.z >= depth - border) {
            currentBoid.position.z -= currentBoid.velocity.z;
            currentBoid.position.z = Math.max(currentBoid.position.z, -depth + border);
            currentBoid.position.z = Math.min(currentBoid.position.z,  depth - border);
            currentBoid.velocity.z = -currentBoid.velocity.z;
            currentBoid.position.z += currentBoid.velocity.z;
        }
    }
        
    Boid.prototype.distance = function(boid, currentBoid) {
        var distX = currentBoid.position.x - boid.position.x;
        var distY = currentBoid.position.y - boid.position.y;
        var distZ = currentBoid.position.z - boid.position.z;
        return Math.sqrt(distX * distX + distY * distY + distZ * distZ);
    }
        
    Boid.prototype.moveAway = function(boids, currentBoid, minDistance) {
        var distanceX = 0;
        var distanceY = 0;
        var distanceZ = 0;
        var numClose = 0;

        for(var i = 0; i < boids.length; i++) {
            var boid = boids[i];
            
            if(boid.position.x == currentBoid.position.x && boid.position.y == currentBoid.position.y && boid.position.z == currentBoid.position.z) continue;
            
            var distance = this.distance(boid, currentBoid);
            if(distance < minDistance) {
                numClose++;
                var xdiff = (currentBoid.position.x - boid.position.x);
                var ydiff = (currentBoid.position.y - boid.position.y);
                var zdiff = (currentBoid.position.z - boid.position.z);

                if(xdiff >= 0) xdiff = Math.sqrt(minDistance) - xdiff;
                else if(xdiff < 0) xdiff = -Math.sqrt(minDistance) - xdiff;

                if(ydiff >= 0) ydiff = Math.sqrt(minDistance) - ydiff;
                else if(ydiff < 0) ydiff = -Math.sqrt(minDistance) - ydiff;

                if(zdiff >= 0) zdiff = Math.sqrt(minDistance) - zdiff;
                else if(zdiff < 0) zdiff = -Math.sqrt(minDistance) - zdiff;

                distanceX += xdiff;
                distanceY += ydiff;
                distanceZ += zdiff;
                boid = null; 
            }
        }
        
        if(numClose == 0) return;
        
        currentBoid.velocity.x -= distanceX / 5;
        currentBoid.velocity.y -= distanceY / 5;
        currentBoid.velocity.z -= distanceZ / 5;
    }
        
    Boid.prototype.moveCloser = function(boids, currentBoid, distance) {
        if(boids.length < 1) return             

        var avgX = 0;
        var avgY = 0;
        var avgZ = 0;
        var maxVelocity = 3;

        for(var i = 0; i < boids.length; i++) {
            var boid = boids[i];
            if(boid.position.x == currentBoid.position.x && boid.position.y == currentBoid.position.y && boid.position.z == currentBoid.position.z) continue;
            if(this.distance(boid, currentBoid) > distance) continue;
            
            avgX += (currentBoid.position.x - boid.position.x);
            avgY += (currentBoid.position.y - boid.position.y);
            avgZ += (currentBoid.position.z - boid.position.z);
            boid = null;
        }
            

        avgX /= boids.length;
        avgY /= boids.length;
        avgZ /= boids.length;

        distance = Math.sqrt((avgX * avgX) + (avgY * avgY) + (avgZ * avgZ)) * -1.0;
        if(distance == 0) return;
        
        currentBoid.velocity.x = Math.min(currentBoid.velocity.x + (avgX / distance) * 0.15, maxVelocity);
        currentBoid.velocity.y = Math.min(currentBoid.velocity.y + (avgY / distance) * 0.15, maxVelocity);
        currentBoid.velocity.z = Math.min(currentBoid.velocity.z + (avgZ / distance) * 0.15, maxVelocity);
    }
        
    Boid.prototype.moveWith = function(boids, currentBoid, distance) {
        if(boids.length < 1) return

        // calculate the average velocity of the other boids
        var avgX = 0;
        var avgY = 0;
        var avgZ = 0;
        var maxVelocity = 5;

        for(var i = 0; i < boids.length; i++) {
            var boid = boids[i];
            if(boid.position.x == currentBoid.position.x && boid.position.y == currentBoid.position.y && boid.position.z == currentBoid.position.z) continue;
            if(this.distance(boid, currentBoid) > distance) continue;
            
            avgX += boid.velocity.x;
            avgY += boid.velocity.y;
            avgZ += boid.velocity.z;
            boid = null;
        }
        avgX /= boids.length;
        avgY /= boids.length;
        avgZ /= boids.length;

        distance = Math.sqrt((avgX * avgX) + (avgY * avgY) + (avgZ * avgZ)) * 1.0;
        if(distance == 0) return;

        currentBoid.velocity.x = Math.min(currentBoid.velocity.x + (avgX / distance) * 0.05, maxVelocity);
        currentBoid.velocity.y = Math.min(currentBoid.velocity.y + (avgY / distance) * 0.05, maxVelocity); 
        currentBoid.velocity.z = Math.min(currentBoid.velocity.z + (avgZ / distance) * 0.05, maxVelocity);                     
    }

    Boid.prototype.fleeMouse = function(mouseVector, currentBoid) {

        var distanceX = 0;
        var distanceY = 0;
        var numClose = 0;

        //if(mouseVector.position.x == currentBoid.position.x && mouseVector.position.y == currentBoid.position.y) continue;
        
        var distance = 5;
        var minDistance = 10/*this.distance(mouseVector, currentBoid)*/;
        
        if(distance < minDistance) {
            numClose++;
            var xdiff = (currentBoid.position.x - mouseVector.x);
            var ydiff = (currentBoid.position.y - mouseVector.y);

            if(xdiff >= 0) xdiff = Math.sqrt(minDistance) - xdiff;
            else if(xdiff < 0) xdiff = -Math.sqrt(minDistance) - xdiff;

            if(ydiff >= 0) ydiff = Math.sqrt(minDistance) - ydiff;
            else if(ydiff < 0) ydiff = -Math.sqrt(minDistance) - ydiff;

            distanceX += xdiff;
            distanceY += ydiff;
            mouseVector = null; 
        }
        
        if(numClose == 0) return;
        
        currentBoid.velocity.x -= distanceX / 5;
        currentBoid.velocity.y -= distanceY / 5;
    }

    var random = function(maxNum) {
        return Math.ceil(Math.random() * maxNum);
    }

    return Boid;
})();



var Fish = (function(){

    function Fish(color){
        THREE.Object3D.call(this);

        // White Eye
        var geometryWhiteEye = new THREE.CylinderGeometry(10, 10, 20, 32); 
        var materialWhiteEye = new THREE.MeshPhongMaterial({
            ambient: 0x000000, 
            color: 0xFFFFFF, 
            specular: 0xFFFFFF, 
            shininess: 30, 
            shading: THREE.FlatShading
        });
        this.whiteEye = new THREE.Mesh(geometryWhiteEye, materialWhiteEye); 
        this.whiteEye.position.set(40, 10, 5);
        this.whiteEye.rotation.set(1.58, 0, 0);
        this.add(this.whiteEye);

        // Black Eye
        var geometryBlackEye = new THREE.CylinderGeometry(5, 5, 22, 32); 
        var materialBlackEye = new THREE.MeshPhongMaterial({
            ambient: 0x000000, 
            color: 0x000000, 
            specular: 0x000000, 
            shininess: 30, 
            shading: THREE.FlatShading
        });
        this.blackEye = new THREE.Mesh(geometryBlackEye, materialBlackEye); 
        this.blackEye.position.set(37, 11, 5);
        this.blackEye.rotation.set(1.58, 0, 0);
        this.add(this.blackEye);

        // Fish Corps
        var extrudeSettings = { 
            amount: 10,
            curveSegments: 100,
            bevelEnabled: false,
            bevelThickness: 10,
            bevelSegments: 20,
            steps: 2
        };

		var x = y = 0;
        var fishShape = new THREE.Shape();

		fishShape.moveTo(x,y);
		fishShape.quadraticCurveTo(x + 50, y - 50, x + 110, y - 10);
		fishShape.quadraticCurveTo(x + 100, y - 10, x + 150, y - 30);
		fishShape.quadraticCurveTo(x + 115, y, x + 150, y + 50);
		fishShape.quadraticCurveTo(x + 100, y + 10, x + 110, y + 50);
		fishShape.quadraticCurveTo(x + 50, y + 50, x, y);

		var geometryCorps = new THREE.ExtrudeGeometry(fishShape, extrudeSettings); 
		var materialCorps = new THREE.MeshPhongMaterial({
            ambient: 0x000000, 
            color: color, 
            specular: 0xAAAAAA, 
            shininess: 5, 
            shading: THREE.FlatShading
        });

	    this.corps = new THREE.Mesh(geometryCorps, materialCorps);
	    this.corps.position.set(0, 0, 0);
	    this.add(this.corps);

	    this.scale.set(0.3, 0.3, 0.3);

		//addShape( fishShape, extrudeSettings, 0x3facc8, -60, 200, 0, 0, 0, 0, 1 );
    }

    Fish.prototype = new THREE.Object3D;
    Fish.prototype.constructor = Fish;

    Fish.prototype.update = function() {

        TweenMax.to(this.rotation, 0.3, {y: (Math.atan2(-this.velocity.z, -this.velocity.x)), z: (-Math.asin(this.velocity.y / this.velocity.length()) * 0.2), ease:Linear.easeNone});
        //this.rotation.y = Math.atan2(-this.velocity.z, -this.velocity.x);
        //this.rotation.z = -Math.asin(this.velocity.y / this.velocity.length()) * 0.2;
    };

    return Fish;
})();


var Grass = (function(){

    function Grass(width, height){
        THREE.Object3D.call(this);

        var geometry = new THREE.BoxGeometry(1.5, 20, 1.5);
        var materials = [
            new THREE.MeshPhongMaterial({
                ambient: 0x000000, 
                color: 0x00FF3E,
                specular: 0x555555,
                shininess: 30, 
                shading: THREE.FlatShading
            }), 
            new THREE.MeshPhongMaterial({
                ambient: 0x000000, 
                color: 0x00997C, 
                specular: 0x555555,
                shininess: 30, 
                shading: THREE.FlatShading
            }),
            new THREE.MeshPhongMaterial({
                ambient: 0x000000, 
                color: 0x00CCA5, 
                specular: 0x555555,
                shininess: 30, 
                shading: THREE.FlatShading
            })
        ];

        for (var i = 0; i < 7500 ; i++) {

            //var random = Math.floor(Math.random() * 3) + 0;

            this.mesh = new THREE.Mesh(geometry, materials[i%3]);
            this.mesh.position.x = (-width/2) + Math.random() * width;
            this.mesh.position.y = -120/*(-height/2) + Math.random() * (height/2.5)*/;
            this.mesh.position.z = (-250) + Math.random() * 500;
            this.mesh.rotation.x = (Math.random() * 0.3) + 9.5;
            this.mesh.scale.y = Math.random() * 1.8 + 0.2;
            //this.mesh.rotation.y = Math.random() + 10;
            //this.mesh.material.color.setHex(colors[i%3]);
            this.add(this.mesh);
        };
        
    }

    Grass.prototype = new THREE.Object3D;
    Grass.prototype.constructor = Grass;

    Grass.prototype.update = function() {

        var time = Date.now() / 3000;

        for (var i = 0, l = this.children.length ; i < l ; i ++) {
            var mesh = this.children[i];
            mesh.rotation.x = (Math.sin(time * 4) * 0.1) + 9.6;
            //mesh.rotation.y = (Math.sin(time * 4)) + 50;
        }
    };

    return Grass;
})();
var Particle = (function(){

    function Particle(){
        THREE.Object3D.call(this);


        // create the particle variables
        var particleCount = 500;
        var particles = new THREE.Geometry();
        var pMaterial = new THREE.PointCloudMaterial({
              color: 0x088DA5,
              size: 2
            });

        // now create the individual particles
        for (var p = 0; p < particleCount; p++) {

            // create a particle with random
            // position values, -250 -> 250
            var pX = Math.random() * 1000 - 500;
            var pY = Math.random() * 1000 - 500;
            var pZ = Math.random() * 1000 - 500;
            var particle = new THREE.Vector3(pX, pY, pZ);

            // add it to the geometry
            particles.vertices.push(particle);
        }

        // create the particle system
        this.particleSystem = new THREE.PointCloud(particles, pMaterial);

        // add it to the scene
        this.add(this.particleSystem);
    }

    Particle.prototype = new THREE.Object3D;
    Particle.prototype.constructor = Particle;

    Particle.prototype.update = function() {
        var time = Date.now() * 0.00005;
        //this.particleSystem.rotation.y = time * ( i < 4 ? i + 1 : - ( i + 1 ) );
        this.particleSystem.rotation.x -= 0.002;
        this.particleSystem.rotation.y += 0.002;
    };

    return Particle;
})();
var Plane = (function(){

    function Plane(){
        THREE.Object3D.call(this);

        var geometry = new THREE.PlaneBufferGeometry(2000, 600);
        var material = new THREE.MeshPhongMaterial({
            ambient: 0x000000, 
            color: 0x002654, 
            specular: 0x444444, 
            shininess: 5, 
            shading: THREE.FlatShading
        });

        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(0, 150, -300);
        this.add(this.mesh);
    }

    Plane.prototype = new THREE.Object3D;
    Plane.prototype.constructor = Plane;

    Plane.prototype.update = function() {

    };

    return Plane;
})();
var Plant = (function(){

    function Plant(width, height){
        THREE.Object3D.call(this);

        // Random
        var randomPoints = [];
        var size = (Math.random()*3) + 4;

        for ( var i = 0; i < size; i ++ ) {
            randomPoints.push(new THREE.Vector3((i - 4.5) * 50, THREE.Math.randFloat(-20, 20), THREE.Math.randFloat(5, 10)));
        }

        var randomSpline =  new THREE.SplineCurve3(randomPoints);
        
        // Plant
        var extrudeSettings = {
            steps           : 200,
            bevelEnabled    : false,
            extrudePath     : randomSpline
        };

        var pts = [], numPts = 2;

        for (var i = 0 ; i < numPts * 2 ; i++) {
            var l = i % 2 == 1 ? 5 : 10;
            var a = i / numPts * Math.PI;
            pts.push(new THREE.Vector2(Math.cos(a) * l, Math.sin(a) * l));
        }

        var shape = new THREE.Shape(pts);
        var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        var material = new THREE.MeshPhongMaterial({
            ambient: 0x000000, 
            color: 0x00CCA5, 
            specular: 0xFFFFFF, 
            shininess: 5, 
            shading: THREE.FlatShading
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.rotation.set(0, 0, 1.58);

        this.add(this.mesh);
    }

    Plant.prototype = new THREE.Object3D;
    Plant.prototype.constructor = Plant;

    Plant.prototype.update = function() {
        /*this.mesh.rotation.x += 0.01;
        this.mesh.rotation.y += 0.01;*/
    };

    return Plant;
})();
var Shark = (function(){

    function Shark(){
        THREE.Object3D.call(this);

        // White Eye
        var geometryWhiteEye = new THREE.BoxGeometry(35, 35, 10); 
        var materialWhiteEye = new THREE.MeshPhongMaterial({
            ambient: 0x000000, 
            color: 0xFFFFFF, 
            specular: 0xFFFFFF, 
            shininess: 30, 
            shading: THREE.FlatShading
        });
        this.whiteEye = new THREE.Mesh(geometryWhiteEye, materialWhiteEye); 
        this.whiteEye.position.set(40, 14, 5);
        this.whiteEye.rotation.set(1.58, 0, 0);
        this.add(this.whiteEye);

        // Black Eye
        var geometryBlackEye = new THREE.CylinderGeometry(4, 4, 37, 32); 
        var materialBlackEye = new THREE.MeshPhongMaterial({
            ambient: 0x000000, 
            color: 0x000000, 
            specular: 0x000000, 
            shininess: 30, 
            shading: THREE.FlatShading
        });
        this.blackEye = new THREE.Mesh(geometryBlackEye, materialBlackEye); 
        this.blackEye.position.set(45, 14, 5);
        this.blackEye.rotation.set(1.58, 0, 0);
        this.add(this.blackEye);

        // Shark Corps
        var extrudeSettings = { 
            amount: 10,
            curveSegments: 100,
            bevelEnabled: false,
            bevelThickness: 10,
            bevelSegments: 20,
            steps: 2
        };

		var x = y = 0;
        var sharkShape = new THREE.Shape();

		sharkShape.moveTo(x,y);
		sharkShape.quadraticCurveTo(x + 100, y - 40, x + 100, y - 10);
		sharkShape.quadraticCurveTo(x + 100, y - 10, x + 170, y - 60);
		sharkShape.quadraticCurveTo(x + 115, y, x + 150, y + 60);
		sharkShape.quadraticCurveTo(x + 100, y + 10, x + 110, y + 80);
		sharkShape.quadraticCurveTo(x + 50, y + 30, x-50, y);

		var geometryCorps = new THREE.ExtrudeGeometry(sharkShape, extrudeSettings); 
		var materialCorps = new THREE.MeshPhongMaterial({
            ambient: 0x000000, 
            color: 0x555555, 
            specular: 0xAAAAAA, 
            shininess: 30, 
            shading: THREE.FlatShading
        });

	    this.corps = new THREE.Mesh(geometryCorps, materialCorps);
	    this.corps.position.set(0, 0, 0);
	    this.add(this.corps);

        this.scale.set(2, 2, 2);

		//addShape( sharkShape, extrudeSettings, 0x3facc8, -60, 200, 0, 0, 0, 0, 1 );
    }

    Shark.prototype = new THREE.Object3D;
    Shark.prototype.constructor = Shark;

    Shark.prototype.update = function() {

        var time = Date.now() / 150;

        this.rotation.y = Math.sin(time) * 0.05;

            var move = Math.sin(Date.now() / 2000);
            var change = true;

            this.position.x -= 20;
/*
            if(move < 0 && change) {
                this.rotation.y = 0;
                change = false;
            }
            else {
                this.rotation.y = 3 * Math.sin(Date.now() / 1500);
                change = true;
            }*/

    	//this.rotation.y -= 0.01;
        //if(this.position.x > 0)
    	//this.position.x -= 5;

        /*
        this.velocity = new THREE.Vector3(-Math.random(), 0, 0);
        this.velocity.x -= Math.random() * 0.1;
*/      
    };

    return Shark;
})();
var Skybox = (function(){

    function Skybox(){
        THREE.Object3D.call(this);

        var r = "src/img/";
        var urls = [r + "whirlpool_py.jpg", r + "whirlpool_py.jpg",
                    r + "whirlpool_py.jpg", r + "whirlpool_ny.jpg",
                    r + "whirlpool_py.jpg", r + "whirlpool_py.jpg"];

        var textureCube = THREE.ImageUtils.loadTextureCube( urls );
        textureCube.format = THREE.RGBFormat;

        // Skybox

        var shader = THREE.ShaderLib[ "cube" ];
        shader.uniforms[ "tCube" ].value = textureCube;

        var geometry = new THREE.BoxGeometry(100, 100, 100);
        var material = new THREE.ShaderMaterial( {

            fragmentShader: shader.fragmentShader,
            vertexShader: shader.vertexShader,
            uniforms: shader.uniforms,
            depthWrite: false,
            side: THREE.BackSide

        } );

        this.mesh = new THREE.Mesh(geometry, material);
        //this.mesh.scale.set(10, 10, 10);

		this.add(this.mesh);
    }

    Skybox.prototype = new THREE.Object3D;
    Skybox.prototype.constructor = Skybox;

    Skybox.prototype.update = function() {
        
    };

    return Skybox;
})();
var Sound = (function(){

    function Sound(){

        myAudio = new Audio('src/audio/PlongeeNocturne.mp3'); 
		myAudio.addEventListener('ended', function() {
		    this.currentTime = 0;
		    this.play();
		}, false);
		myAudio.play();
    }

    Sound.prototype.constructor = Sound;

    return Sound;
})();
var Sphere = (function(){

    function Sphere(){
        THREE.Object3D.call(this);

        var geometry = new THREE.SphereGeometry(35);
        var material = new THREE.MeshPhongMaterial({
            ambient: 0x000000, 
            color: 0x00C0C0, 
            specular: 0xAAAAAA, 
            shininess: 30, 
            shading: THREE.FlatShading
        });

        this.mesh = new THREE.Mesh(geometry, material);
        this.add(this.mesh);
    }

    Sphere.prototype = new THREE.Object3D;
    Sphere.prototype.constructor = Sphere;

    Sphere.prototype.update = function() {
        this.mesh.rotation.x += 0.01;
        this.mesh.rotation.y += 0.01;
    };

    return Sphere;
})();
//# sourceMappingURL=app.min.js.map